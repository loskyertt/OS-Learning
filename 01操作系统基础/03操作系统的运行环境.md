# 1.处理机运行模式

---

## 1.1 内核程序和应用程序

- **应用程序（User Program）：** 是用户运行的软件，比如微信、Word、VS Code；
- **内核程序（Kernel Code）：** 是操作系统里最核心的部分，比如负责进程调度、内存分配、系统调用等。

“操作系统内核”（或简称“内核（Kernel）”）是由很多 **内核程序** 组成的，这些“内核程序”通常以模块或组件的形式存在，比如：
- 进程调度器
- 内存管理器
- I/O 管理
- 系统调用处理器
- 驱动程序管理器（有些驱动也在内核层）

内核是操作系统最重要最核心的部分，也是 **最接近硬件** 的部分。某些软件（如容器、服务器）只需要内核即可运行，而不需要完整的操作系统“用户空间程序”。

操作系统的功能未必都在内核中，如 **图形化用户界面** （Linux 系统的内核不自带 GUI，桌面环境如 GNOME、KDE 是运行在“用户空间”的）。

---

## 1.2 特权指令和非特权指令

在 CPU 设计和生产时就划分了特权指令和非特权指令，因此 CPU 执行一条指令前就可以判断出其类型。

> 特权指令是只有操作系统内核（Kernel Mode）才能执行的指令，而非特权指令是用户程序（User Mode）可以自由执行的指令。普通用户程序如果尝试执行特权指令，会触发 **异常（Exception）** 或 **陷阱（Trap）**，被操作系统拦截。

常见的特权指令：

| **类别**     | **指令**     | **作用**                                       |
| ------------ | ------------ | ---------------------------------------------- |
| **CPU 控制** | `HLT`        | 停止 CPU（Halting the CPU）                    |
|              | `CLI`        | 关闭中断（Clear Interrupt Flag）               |
|              | `STI`        | 开启中断（Set Interrupt Flag）                 |
|              | `IRET`       | 从中断返回（Interrupt Return）                 |
| **内存管理** | `LGDT`       | 加载全局描述符表（GDT）                        |
|              | `LLDT`       | 加载局部描述符表（LDT）                        |
|              | `LTR`        | 加载任务寄存器（Task Register）                |
| **I/O 操作** | `IN` / `OUT` | 访问 I/O 端口（输入/输出设备）                 |
| **模式切换** | `MOV CRx`    | 修改控制寄存器（如 `CR0`, `CR3` 用于内存分页） |

常见的非特权指令:

| **类别**       | **指令**                 | **作用**       |
| -------------- | ------------------------ | -------------- |
| **数据传输**   | `MOV`                    | 数据传输       |
|                | `PUSH` / `POP`           | 堆栈操作       |
| **算术运算**   | `ADD` / `SUB`            | 加法 / 减法    |
|                | `MUL` / `DIV`            | 乘法 / 除法    |
| **逻辑运算**   | `AND` / `OR` / `XOR`     | 逻辑运算       |
| **分支控制**   | `JMP`                    | 无条件跳转     |
|                | `CALL` / `RET`           | 调用函数和返回 |
| **字符串操作** | `MOVS` / `LODS` / `STOS` | 字符串操作     |
| **浮点运算**   | `FADD` / `FSUB`          | 浮点加减       |

> 特权指令的作用:
> - **保护操作系统安全**：防止用户程序直接访问系统关键资源（如内存、设备）。
> - **防止系统崩溃**：如果用户程序能随意执行 `HLT`，整个计算机可能会被停止。
> - **控制资源访问**：比如 `MOV CR3` 控制内存分页表，决定进程的内存映射，不能让普通程序修改。

> 非特权指令的作用：
> - **用户程序可以自由执行**，不会影响系统安全。
> - **不涉及硬件资源管理**，不会访问 I/O 端口、修改内存映射等。
> - **适用于应用程序**，如计算、数据存储、逻辑判断等。

---

## 1.3 内核态和用户态

- 处于内核态时，说明此时正在运行的是内核程序，此时可以执行特权指令；
- 处于用户态时，说明此时正在运行的是应用程序，此时只能执行非特权指令。

> CPU 中有一个寄存器叫 **程序状态寄存器（PSW）** ，其中有个二进制位，1 表示内核态，0 表示用户态。

> **别名：** 内核态 = 核心态 = 管态；用户态 = 目态

- **用户态 —> 内核态：** 由 **“中断”** 引发， **硬件自动完成** 变态过程，触发中断信号意味着操作系统将重新夺回 CPU 的使用权。
- **内核态 —> 用户态：** 操作系统通过执行“恢复上下文”的 **特权指令** ，让 **CPU 自己去改 PSW** ，完成态的切换。这个过程通常在 **“中断处理结束”** 或 **“系统调用处理完”** 后发生。

| 切换方向            | 谁触发               | 谁执行                                | CPU 做了什么                   |
| ------------------- | -------------------- | ------------------------------------- | ------------------------------ |
| **用户态 → 内核态** | 系统调用、中断、异常 | **CPU 硬件自动切换**                  | 保存上下文、修改 PSW、跳转入口 |
| **内核态 → 用户态** | 操作系统主动还权     | **操作系统调用特权指令（如 `iret`）** | 恢复上下文、切回用户态         |

---

# 2.中断和异常

---

## 2.1 中断的作用

**中断** 会使 CPU 由 **用户态 -> 内核态** （需要始终记住，这是由硬件完成的！），使操作系统重新夺回对 CPU 的控制权。中断是让操作系统内核夺回 CPU 使用权的 **唯一途径** ，如果没有中断机制，那么一旦应用程序上 CPU 运行，CPU 就会一直运行这个应用程序。

## 2.2 中断的类型


