# 1.同步与互斥的概念

---

## 1.1 基本概念

- **异步性：** 即各并发执行的进程以不可预知的速度向前推进。
- **同步性：** ***多个进程以一定的顺序来执行*** 。同步亦称 **直接制约关系** ，它是指完成某种任务而建立的两个或多个进程因为需要在某些位置上 **协调** 它们的 **工作次序** 而产生的制约关系。

- **互斥（资源共享方式）：** 互斥亦称 **间接制约关系** 。
    - 互斥共享方式：系统中的某些资源，虽然可以提供给多个进程使用，但是一个时间段内 **只允许一个** 进程访问该资源。
    - 同时共享方式：系统中的某些资源，运行一个时间段内由 **多个进程“同时”** 对它们进行访问。

- **临界资源：** 一个时间段内只允许一个进程使用的资源。如：物理设备（摄像头、打印机）都属于临界资源，此外还有许多变量、数据、内存缓冲区都属于临界资源。因此对临界资源的访问，必须 **互斥** 地进行。

对临界资源的互斥访问，可以逻辑上分为四个部分：
```C
do {
    /**
     * 进入区
     * 负责检查是否可以进入临界区
     * 若可以进入，则应设置正在访问临界资源的标志(上锁)
     * 以阻止其它进程同时访问临界区
     */
    entry section;
    /**
     * 临界区
     * 访问临界资源的代码
     */
    critical section;
    /**
     * 退出区
     * 负责解除正在访问临界资源的标志(解锁)
     */
    exit section;
    /**
     * 剩余区
     * 做其它处理
     */   
    remainder section;
} while (true)
```

实现对临界资源的互斥访问，同时保证系统整体性能，需要遵循 **四** 个原则：
1. **空闲让进：** 临界区空闲时，可以允许一个请求进入临界区的进程进入临界区
2. **忙则等待：** 当已有进程进入临界区时，其他试图进入临界区的进程必须等待
3. **有限等待：** 当请求访问的进程，应保证能在有限的时间内进入临界区（保存不会饥饿）
4. **让权等待：** 当进程不能进入临界区，应立即释放处理机，防止进程忙等

---

# 2.互斥的实现方式

---

## 2.1 互斥的软件实现方式

---

### 2.1.1 单标志法

算法思想：
> 两个进程在访问临界区后会把使用临界区的权限转交给另一个进程。也就是说 **每个进程进入临界区的权限只能被另一个进程赋予** 。
```C
int turn = 0; // turn 表示当前允许进入临界区的进程号(表示谦让)

// P0 进程
while (trun != 0);
critical section;
turn = 1;
remainder section;

// P1 进程
while (trun != 1);
critical section;
turn = 0;
remainder section;
```

主要问题： 违背了 **空闲让进** 原则：
> 当`turn = 0`，`P0`进程不需要访问临界区，`P1`进程需要访问临界区，这样就会导致`P1`不能访问，但此时临界区时空闲的。

---

### 2.1.2 双标志先检查法

算法思想：
> 设置一个布尔类型数组`flag[]`，数组中各个元素用来标记 **各进程想进入临界区的意愿**，比如`flag[0] = true`意味着`0`号进程`P0`现在想进入临界区。每个进程在进入临界区之前先检查当前有没有别的进程想进入临界区，如果没有，则把自身对应的标志`flag[i]`设为`true`，之后开始访问临界区。
```C
bool flag[2]; // 表示进入临界区意愿的数组(表达意愿)
flag[0] = false; // P0 进程不想进入临界区
flag[1] = false; // P1 进程不想进入临界区

// P0 进程
while (flag[1]);   // 如果此时 P1 想进入临界区，P0 就一直循环等待 (检查)
flag[0] = true;    // 标记为 P0 进程想进入临界区 (上锁)
critical section;  // 访问临界区
flag[0] = false;   // 访问完临界区，修改标记为 P0 不想使用临界区
remainder section; //

// P1 进程
while (flag[0]);
flag[1] = true;
critical section;
flag[1] = false;
remainder section;
```

主要问题：违背了 **忙则等待** 原则
> 最开始，两个进程数组对应的值都为`false`，两个进程同时访问临界区，由于都为`false`，所以可以直接运行到`while`循环后。
>> 原因： **检查（从`while`的判断开始）** 和 **上锁（到`flag[i] = false`结束）** 不能一气呵成。

---

### 2.1.3 双标志后检查法

算法思想：
> 在双标志先检查法的基础上进行了改进， **先上锁，后检查** 。
```C
bool flag[2]; // 表示进入临界区意愿的数组(表达意愿)
flag[0] = false; // P0 进程不想进入临界区
flag[1] = false; // P1 进程不想进入临界区

// P0 进程
flag[0] = true;    // 标记为 P0 进程想进入临界区 (上锁)
while (flag[1]);   // 如果此时 P1 想进入临界区，P0 就一直循环等待 (检查)
critical section;  // 访问临界区
flag[0] = false;   // 访问完临界区，修改标记为 P0 不想使用临界区
remainder section; //

// P1 进程
flag[1] = true;
while (flag[0]);
critical section;
flag[1] = false;
remainder section;
```
主要问题：违背了 **空闲让进** & **有限等待** 原则
> 可能两个进程同时上锁，导致谁都不能访问临界区，产生 **死等**。注意和死锁的区别！

---

### 2.1.4 Peterson 算法

算法思想：
> 结合双标志法，单标志法的思想。如果双方都争着进入临界区，那可以让进程尝试 **互相谦让**，即表达自己想进入临界区的意愿，但是先让别人访问。

```C
bool flag[2]; // 表示进入临界区意愿的数组(表达意愿)
int turn = 0; // 表示当前允许进入临界区的进程号(表示谦让)
// P0 进程
flag[0] = true; // 表示 P0 想要进入
turn = 1;   // 对 P1 谦让
while (flag[1] && turn == 1);   // 如果 P1 真的想进，且自己已经“谦让”了，那就在这儿等着（被循环卡住）
critical section;
flag[0] = false;
remainder section;

// P1 进程
flag[1] = true;
turn = 0;
while (flag[0] && turn == 0);
critical section;
flag[1] = false;
remainder section;
```
主要问题：违背了 **让权等待** 原则

---

## 2.2 互斥的硬件实现方法

**执行的过程不允许被中断，都是一气呵成！**

---

### 2.2.1 中断屏蔽法

利用 **开/关中断指令** 实现（与原语实现的思想一样，即一个进程访问临界区前先关中断，访问完成后开中断，这样就不可能发生两个同时访问临界区的情况）。

![alt text](imgs/开关中断.png)

- 优点：简单，高效
- 缺点：**不适用于多处理机**；只适用于操作系统内核程序，**不适用于用户进程**（因为开/关中断指令只能运行在内核态，这组指令如果能让用户随意适用就很危险）

---

### 2.2.2 TestAndSet（TS 指令/TSL 指令）

TSL 指令是 **用硬件实现** 的，执行过程中不允许被中断，只能 **一气呵成** 。

```C
// 布尔型共享变量 lock 表示当前临界区是否被加锁
// true 表示加锁，false 表示未加锁
bool TestAndSet(bool *lock) {
    bool old;
    old = *lock;
    *lock = true;   // 不管加没加锁，最后都会设置成加锁的状态（避免其它进程进入）
    return old;
}

// 以下是使用 TSL 指令实现互斥的算法逻辑
while (TestAndSet(&lock));   // 上锁 并 检查
// 临界区代码段...
lock = false;                // 解锁
// 剩余区代码段...
```

过程：
> 若刚开始`lock`是`false`，则`TSL`返回的`old`值为`false`，`while`循环条件不满足，直接跳过循环，进入临界区。若刚开始`lock`是`true`，则执行`TSL`后`old`返回的值为`true`，`while`循环满足条件，会一直循环，直到当前访问临界区的进程在退出区进行解锁。

- 对比：相比于软件实现方法，`TSL`指令把 **上锁** 和 **检查** 操作用硬件的方式变成了一气呵成的原子操作
- 优点：实现简单，无需像软件实现那样严格检查是否会有逻辑漏洞； **适用于多处理机环境**
- 缺点：不满足 **让权等待** 原则，暂时无法进入临界区的进程会占用`CPU`并循环执行`TSL`指令，从而导致忙等

---

### 2.2.3 Swap 指令（Exchange/XCHG 指令）

Swap 指令是 **用硬件实现** 的，执行的过程不允许被中断，只能 **一气呵成** 。

```C
// Swap 指令的作用是交换两个变量的值
Swap (bool *a, bool *b) {
    bool temp;
    temp = *a;
    *a = *b;
    *b = temp;
}

// 以下是使用 TSL 指令实现互斥的算法逻辑
// lock 表示当前临界区是否被加锁
bool old = true；
while (old == true)
    Swap(&lock, &old);
// 临界区代码段...
lock = false;                // 解锁
// 剩余区代码段...
```

过程：
> 逻辑上与`TSL`并无太大的区别，都是先记录下此时临界区是否已经被上锁（记录在`old`变量上），再将上锁标记`lock`设置为`true`，最后检查`old`，如果`old`为`false`则说明之前没有别的进程对临界区上锁，则可跳出循环，进入临界区。

- 优点：与`TSL`一样。
- 缺点：与`TSL`一样。

---

# 3.信号量机制

用户进程可以通过使用操作系统提供的 **一对原语** 来对信号量进程操作，从而很方便的实现了进程互斥、进程同步。

信号量其实就是一个变量（可以是一个整数，也可以是更复杂的记录型变量），可以用一个信号量来表示系统中某种资源的数量，比如：系统中只有一台打印机，就可以设置一个初值为 1 的信号量

**一对原语：** `wait(S)`、`signal(S)`，简称为`P`、`V`操作。

---

## 3.1 整型信号量

```C
int S = 1; // 初始化整型信号量 S，表示当前系统中可用的打印机资源数

void wait(int S) {   // wait 原语，相当于 进入区
    while (S <= 0);  // 如果资源数不够，就一直循环等待
    S = S - 1;       // 如果资源数够，则占用一个资源
}

void signal(int S) { // signal 原语，相当于 退出区
    S = S + 1;       // 使用完资源后，在退出区释放资源
}

// 进程 P0
wait(S);              // 进入区，申请资源
// 使用打印机资源...
signal(S);            // 退出区，释放资源

// 进程 P1
wait(S);
// 使用打印机资源...
signal(S);

// .......

// 进程 Pn
wait(S);
// 使用打印机资源...
signal(S);
```

缺点：不满足 **让权等待** 原则，会发生 **忙等** 。

---

## 3.2 记录型信号量

用 **记录型数据结构** 表示信号量。

```C
/* 记录型信号量的定义 */
typedef struct {
    int value;          // 剩余资源数
    struct process *L;  // 等待队列
} semaphore;

/**
 * 某进程需要使用资源时，通过 wait 原语申请
 *
 * 对信号量 S 的一次 P 操作意味着进程请求一个单位的该类资源
 * 因此需要执行 S.value--，表示资源数减 1
 * 当 S.value < 0 时表示该类资源已经分配完毕
 * 因此进程应调用 block 原语进行自我阻塞（当前运行的进程从 运行态 -> 阻塞态）
 * 主动放弃处理机，并插入到该类资源的等待队列 S.L 中
 * 可见，该机制遵循了 让权等待 原则，不会出现 忙等 现象
 *
 */
void wait (semaphore S) {
    S.value--;
    while(S.value < 0) {
        // 如果剩余资源数不够，使用 block 原语使进程从运行态进入阻塞态
        // 并把挂到信号量 S 的等待队列(即阻塞队列)中
        // 用 while 而不用 if 的原因：可能多个进程被唤醒，必须重新检查 S.value，确保资源可用才进入临界区
        block(S.L);
    }
}

/**
 * 进程使用完资源后，通过 signal 原语释放
 *
 * 对信号量 S 的一次 V 操作意味着进程释放一个单位的该类资源
 * 因此需要执行 S.value++，表示资源数加 1
 * 若加 1 后仍是 S.value <= 0，表示依然有进程在等待该类资源
 * 因此调用 wakeup 原语唤醒等待队列中的第一个进程
 * （被唤醒进程从 阻塞态 -> 就绪态）
 *
 */
void signal(semaphore S) {
    s.value++;
    if (S.value <= 0) {
        // 释放资源后，若还有别的进程在等待这种资源
        // 则使用 wakeup 原语唤醒等待队列中的一个进程，该进程从阻塞态变为就绪态
        // 用 if 而不用 while 的原因：只唤醒一个等待进程，不需要重复检查
        wakeup(S.L);
    }
}
```

---

# 4.P、V 操作的应用

用信号量机制实现进程同步、互斥、前驱关系。

---

## 4.1 同步关系

进程同步：要让各并发进程按要求有序地推进

分析什么地方需要实现 同步关系，即必须保证 **一前一后** 执行的两个操作：
- 设置同步信号量`S`，初始值为`0`
- 在 **前操作** 之后执行`V(S)`
- 在 **后操作** 之前执行`P(S)`


